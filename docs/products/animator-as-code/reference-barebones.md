---
sidebar_position: 8
---

# Barebones way

:::danger
This is the work-in-progress documentation for Animator As Code **V1**, which has not yet been released. The last public version of Animator As Code is V0.
:::

This section describes how to initialize Animator As Code in an environment where no integration is available.

This is good for:

- Generating Animator Controller assets on-disk.
- Using Animator As Code in a non-VRChat Avatars project.

If you are using VRChat Avatars, it is highly recommended that you look into the [non-destructive workflow examples](getting-started).

## Typical animator creation steps

If you use Animator As Code barebones, it is generally used in the following steps:

- Declare an Animator As Code
- Create one or multiple layers
- Create the states
    - Create the animations at the same time
- Create the transitions

## Declare an Animator As Code (AAC)

:::warning
These steps describe how to use Animator As Code without the help of any other dependency.

In VRChat Avatars, it may be much easier to use Animator As Code [when it is integrated with Modular Avatar and NDMF](getting-started).
:::

In order to use Animator As Code (AAC), first, declare it with a configuration.

The AAC configuration requires the following:

- A system name.
    - Animator As Code describes systems. A system can have multiple layers, not only across playable layer animators, but also within a single playable layer animator. All created layers will be prefixed with this system name.
    - It is up to you to decide where the boundaries of the system lies.
- An animator root, and default value root.
    - This is used to select the playable layer animators to use.
    - This is also used to select the root transform that animations will use for relative paths.
    - This is used to collect the default values for some animations.
    - *In general, they are the same object, but this is not mandatory.*
- *In the case of a destructive workflow in VRChat:* An avatar descriptor.
    - This is used to select the playable layer animators to use.
- An asset container.
    - Animations are generated by Animator As Code, and the large quantity of generated assets can be quite messy. To limit littering your project, such assets will be generated as sub-assets of a container. The container is of type Animator Controller, but it doesn’t need to have any layers within it.
- An asset key.
    - The asset key a prefix that all generated assets will use. When creating the layers, all generated assets that uses that prefix will be removed upon invocation of `aac.ClearPreviousAssets()`.
- A provider of defaults.
    - Animator As Code is opinionated, and sometimes you want to tweak the default values. The provider of defaults is executed when a state is created, an animation is created, a transition is created. This will let you tweak the generation process.

To declare it:

```csharp
string systemName;
VRCAvatarDescriptor avatar;
AnimatorController assetContainer;
string assetKey;

var aac = AacV0.Create(new AacConfiguration
{
    SystemName = systemName,
    AvatarDescriptor = avatar,
    AnimatorRoot = avatar.transform,
    DefaultValueRoot = avatar.transform,
    AssetContainer = assetContainer,
    AssetKey = assetKey,
    DefaultsProvider = new AacDefaultsProvider(writeDefaults: false)
});
// Remove all previously generated assets from the asset container
// that match the asset key.
aac.ClearPreviousAssets();
```

## Create one or multiple layers

Using AAC, create layers in your animators. A system can have multiple layers across animators.

There is one main layer, and multiple supporting layers, per animator.

- The main layer will be named exactly after your system name.
- The supporting layers will be prefixed by the system name, and appended with a suffix of your choice.

You are in no obligation to create a main layer. If you think several layers of the same animators are of equal importance, you can declare them as being supporting layers.

```csharp
var fx = aac.CreateMainFxLayer();
var detection = aac.CreateSupportingFxLayer("Detection");
```
