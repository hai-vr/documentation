"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[3269],{3427:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>a,contentTitle:()=>r,default:()=>d,frontMatter:()=>s,metadata:()=>l,toc:()=>h});var t=i(74848),o=i(28453);const s={},r="Kinematics Solver",l={id:"resilience/internal/kinematics/kinematics-solver",title:"Kinematics Solver",description:"Inverse Kinematics solver",source:"@site/docs/resilience/internal/kinematics/kinematics-solver.md",sourceDirName:"resilience/internal/kinematics",slug:"/resilience/internal/kinematics/kinematics-solver",permalink:"/docs/resilience/internal/kinematics/kinematics-solver",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"resilienceSidebar",previous:{title:"Execution order",permalink:"/docs/resilience/internal/execution-order"},next:{title:"Oblique Projected Surface",permalink:"/docs/resilience/internal/overlay/oblique-projected-surface"}},a={},h=[{value:"Inverse Kinematics solver",id:"inverse-kinematics-solver",level:2},{value:"General IK solver strategy",id:"general-ik-solver-strategy",level:3},{value:"Solve position first, then rotation",id:"solve-position-first-then-rotation",level:3},{value:"Straddling: Switching from end effector to joint effector",id:"straddling-switching-from-end-effector-to-joint-effector",level:3},{value:"Stateful IK: Wrist torque",id:"stateful-ik-wrist-torque",level:3}];function c(e){const n={h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",ul:"ul",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"kinematics-solver",children:"Kinematics Solver"}),"\n",(0,t.jsx)(n.h2,{id:"inverse-kinematics-solver",children:"Inverse Kinematics solver"}),"\n",(0,t.jsx)(n.h3,{id:"general-ik-solver-strategy",children:"General IK solver strategy"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Pre-pose the bones to facilitate solving:","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"The IK solver suffers from an issue where a solution would fail to converge in a low number of iterations\nif the position of the end effector is aligned with the initial pose, because its joints will refuse to bend."}),"\n",(0,t.jsx)(n.li,{children:"Pre-posing will also suggest the bend direction for that particular pose."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["Solve the spine chain first:","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["The spine chain is currently the only chain in the humanoid pose that has more than one joint.","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"In this version of the solver, the wrist is not considered to be a joint.\nThis may change in future version of the solver, once an abstraction of the fingertips become the end effectors so that the wrist becomes free to move."}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.li,{children:"Solve the spine bone positions."}),"\n",(0,t.jsx)(n.li,{children:"Solve the spine bone rotations."}),"\n",(0,t.jsx)(n.li,{children:"The spine chain is not a function of the hand or arm placements: only the hips, chest, and head placements influence the spine chain."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["Solve all other arm chains.","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"The root point of the arm is always the result of the spine being solved."}),"\n",(0,t.jsx)(n.li,{children:"Solve each arm bone positions."}),"\n",(0,t.jsx)(n.li,{children:"Solve each arm bone rotations."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"solve-position-first-then-rotation",children:"Solve position first, then rotation"}),"\n",(0,t.jsx)(n.p,{children:"Bone positions are solved before solving the rotations."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["First, we place the bone positions in such a way that the bone lengths are respected.","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Bone positions are not restricted by any rotation limit. Rotation limits that influence bone positions are not part of this IK solver."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["Secondly, we orient the bone rotations to match the solved IK chain.","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"There is some heuristic to orient the bones. For instance, if the arm is straight, then the elbow can rotate freely to some limits (even in real-life),\nand we have to choose a sensible rotation."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"straddling-switching-from-end-effector-to-joint-effector",children:"Straddling: Switching from end effector to joint effector"}),"\n",(0,t.jsx)(n.p,{children:"In its normal function, the IK solver can aim to make the end bones match the end effectors."}),"\n",(0,t.jsx)(n.p,{children:"In alternate function, the IK solver can aim to make the joints point towards a joint effector, and the end bone point towards an end effector."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"This is different from a bend direction, as a bend direction will still aim to make the end bone match the end effector."}),"\n",(0,t.jsx)(n.li,{children:'This function allows the bone chain to "straddle" another object, so that instead of having a known anchor point for the end bone,\nthe end bones becomes free to move as long as the joint is pointing towards a desired direction.'}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"stateful-ik-wrist-torque",children:"Stateful IK: Wrist torque"}),"\n",(0,t.jsx)(n.p,{children:"Controllers only provide some information about the rotation of the wrist. While holding on the controller, the hand can spin more than 360 degrees\non the shoulder-to-hand axis, but it can't spin indefinitely. When spinning in this way, the arm will lock into two different configurations,\nso you can have the controller in a specific rotation with the arm locked inwards, or the controller in the same rotation with the arm locked outwards."}),"\n",(0,t.jsx)(n.p,{children:"With enough past information and assuming the user does not drop the controller, we should be able to deduce whether the arm\nis being locked in one direction or another. To do this, we need to reliably keep track the twist of the controller in relationship to the HMD position."})]})}function d(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}}}]);